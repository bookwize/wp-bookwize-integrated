<?php

if ( ! function_exists( 'http_response_code' ) ) {
	function http_response_code( $code = null ) {
		if ( $code !== null ) {

			switch ( $code ) {
				case 100:
					$text = 'Continue';
					break;
				case 101:
					$text = 'Switching Protocols';
					break;
				case 200:
					$text = 'OK';
					break;
				case 201:
					$text = 'Created';
					break;
				case 202:
					$text = 'Accepted';
					break;
				case 203:
					$text = 'Non-Authoritative Information';
					break;
				case 204:
					$text = 'No Content';
					break;
				case 205:
					$text = 'Reset Content';
					break;
				case 206:
					$text = 'Partial Content';
					break;
				case 300:
					$text = 'Multiple Choices';
					break;
				case 301:
					$text = 'Moved Permanently';
					break;
				case 302:
					$text = 'Moved Temporarily';
					break;
				case 303:
					$text = 'See Other';
					break;
				case 304:
					$text = 'Not Modified';
					break;
				case 305:
					$text = 'Use Proxy';
					break;
				case 400:
					$text = 'Bad Request';
					break;
				case 401:
					$text = 'Unauthorized';
					break;
				case 402:
					$text = 'Payment Required';
					break;
				case 403:
					$text = 'Forbidden';
					break;
				case 404:
					$text = 'Not Found';
					break;
				case 405:
					$text = 'Method Not Allowed';
					break;
				case 406:
					$text = 'Not Acceptable';
					break;
				case 407:
					$text = 'Proxy Authentication Required';
					break;
				case 408:
					$text = 'Request Time-out';
					break;
				case 409:
					$text = 'Conflict';
					break;
				case 410:
					$text = 'Gone';
					break;
				case 411:
					$text = 'Length Required';
					break;
				case 412:
					$text = 'Precondition Failed';
					break;
				case 413:
					$text = 'Request Entity Too Large';
					break;
				case 414:
					$text = 'Request-URI Too Large';
					break;
				case 415:
					$text = 'Unsupported Media Type';
					break;
				case 500:
					$text = 'Internal Server Error';
					break;
				case 501:
					$text = 'Not Implemented';
					break;
				case 502:
					$text = 'Bad Gateway';
					break;
				case 503:
					$text = 'Service Unavailable';
					break;
				case 504:
					$text = 'Gateway Time-out';
					break;
				case 505:
					$text = 'HTTP Version not supported';
					break;
				default:
					exit( 'Unknown http status code "' . htmlentities( $code ) . '"' );
					break;
			}

			$protocol = ( isset( $_SERVER['SERVER_PROTOCOL'] ) ? $_SERVER['SERVER_PROTOCOL'] : 'HTTP/1.0' );

			header( $protocol . ' ' . $code . ' ' . $text );

			$GLOBALS['http_response_code'] = $code;

		} else {
			$code = ( isset( $GLOBALS['http_response_code'] ) ? $GLOBALS['http_response_code'] : 200 );
		}

		return $code;
	}
}

if ( ! function_exists( 'http_build_url' ) ) {
	define( 'HTTP_URL_REPLACE', 1 );              // Replace every part of the first URL when there's one of the second URL
	define( 'HTTP_URL_JOIN_PATH', 2 );            // Join relative paths
	define( 'HTTP_URL_JOIN_QUERY', 4 );           // Join query strings
	define( 'HTTP_URL_STRIP_USER', 8 );           // Strip any user authentication information
	define( 'HTTP_URL_STRIP_PASS', 16 );          // Strip any password authentication information
	define( 'HTTP_URL_STRIP_AUTH', 32 );          // Strip any authentication information
	define( 'HTTP_URL_STRIP_PORT', 64 );          // Strip explicit port numbers
	define( 'HTTP_URL_STRIP_PATH', 128 );         // Strip complete path
	define( 'HTTP_URL_STRIP_QUERY', 256 );        // Strip query string
	define( 'HTTP_URL_STRIP_FRAGMENT', 512 );     // Strip any fragments (#identifier)
	define( 'HTTP_URL_STRIP_ALL', 1024 );         // Strip anything but scheme and host

	// Build an URL
	// The parts of the second URL will be merged into the first according to the flags argument.
	//
	// @param   mixed           (Part(s) of) an URL in form of a string or associative array like parse_url() returns
	// @param   mixed           Same as the first argument
	// @param   int             A bitmask of binary or'ed HTTP_URL constants (Optional)HTTP_URL_REPLACE is the default
	// @param   array           If set, it will be filled with the parts of the composed url like parse_url() would return
	function http_build_url( $url, $parts = array(), $flags = HTTP_URL_REPLACE, &$new_url = false ) {
		$keys = array( 'user', 'pass', 'port', 'path', 'query', 'fragment' );

		// HTTP_URL_STRIP_ALL becomes all the HTTP_URL_STRIP_Xs
		if ( $flags & HTTP_URL_STRIP_ALL ) {
			$flags |= HTTP_URL_STRIP_USER;
			$flags |= HTTP_URL_STRIP_PASS;
			$flags |= HTTP_URL_STRIP_PORT;
			$flags |= HTTP_URL_STRIP_PATH;
			$flags |= HTTP_URL_STRIP_QUERY;
			$flags |= HTTP_URL_STRIP_FRAGMENT;
		} // HTTP_URL_STRIP_AUTH becomes HTTP_URL_STRIP_USER and HTTP_URL_STRIP_PASS
		else if ( $flags & HTTP_URL_STRIP_AUTH ) {
			$flags |= HTTP_URL_STRIP_USER;
			$flags |= HTTP_URL_STRIP_PASS;
		}

		// Parse the original URL
		$parse_url = parse_url( $url );

		// Scheme and Host are always replaced
		if ( isset( $parts['scheme'] ) ) {
			$parse_url['scheme'] = $parts['scheme'];
		}
		if ( isset( $parts['host'] ) ) {
			$parse_url['host'] = $parts['host'];
		}

		// (If applicable) Replace the original URL with it's new parts
		if ( $flags & HTTP_URL_REPLACE ) {
			foreach ( $keys as $key ) {
				if ( isset( $parts[ $key ] ) ) {
					$parse_url[ $key ] = $parts[ $key ];
				}
			}
		} else {
			// Join the original URL path with the new path
			if ( isset( $parts['path'] ) && ( $flags & HTTP_URL_JOIN_PATH ) ) {
				if ( isset( $parse_url['path'] ) ) {
					$parse_url['path'] = rtrim( str_replace( basename( $parse_url['path'] ), '', $parse_url['path'] ), '/' ) . '/' . ltrim( $parts['path'], '/' );
				} else {
					$parse_url['path'] = $parts['path'];
				}
			}

			// Join the original query string with the new query string
			if ( isset( $parts['query'] ) && ( $flags & HTTP_URL_JOIN_QUERY ) ) {
				if ( isset( $parse_url['query'] ) ) {
					$parse_url['query'] .= '&' . $parts['query'];
				} else {
					$parse_url['query'] = $parts['query'];
				}
			}
		}

		// Strips all the applicable sections of the URL
		// Note: Scheme and Host are never stripped
		foreach ( $keys as $key ) {
			if ( $flags & (int) constant( 'HTTP_URL_STRIP_' . strtoupper( $key ) ) ) {
				unset( $parse_url[ $key ] );
			}
		}


		$new_url = $parse_url;

		return
			( ( isset( $parse_url['scheme'] ) ) ? $parse_url['scheme'] . '://' : '' )
			. ( ( isset( $parse_url['user'] ) ) ? $parse_url['user'] . ( ( isset( $parse_url['pass'] ) ) ? ':' . $parse_url['pass'] : '' ) . '@' : '' )
			. ( ( isset( $parse_url['host'] ) ) ? $parse_url['host'] : '' )
			. ( ( isset( $parse_url['port'] ) ) ? ':' . $parse_url['port'] : '' )
			. ( ( isset( $parse_url['path'] ) ) ? $parse_url['path'] : '' )
			. ( ( isset( $parse_url['query'] ) ) ? '?' . $parse_url['query'] : '' )
			. ( ( isset( $parse_url['fragment'] ) ) ? '#' . $parse_url['fragment'] : '' );
	}
}

if ( ! function_exists( 'bw_debug' ) ) {
	function bw_debug( $data = null, $die = false ) {

		$style = ' text-align:left; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; display: block; background:#F7AFDE; border:2px dotted #070; padding: 7px; color:#000; font-family: Consolas, monaco, monospace; font-size:11px;';
		echo '<pre style="' . $style . '">';
		if ( is_array( $data ) ) {
			foreach ( $data as $arg ) {
				print_r( $arg );
			}
		} else {
			print_r( $data );
		}
		echo '</pre>';

		if ( $die ) {
			die();
		}
	}
}

if ( ! function_exists( 'bw_render' ) ) {

	function bw_render( $file = '', $data = [] ) {

        if ($file === '') {
            return false;
        }

        if (substr($file, -4) !== '.php') {
            $file .= '.php';
        }

        extract($data);

        $template = locate_template($file);
        if ($template !== '') {
            ob_start();
            include $template;

            return ob_get_clean();
        }

        $plugin_path = plugin_dir_path(__FILE__);
        $paths = array(
            $plugin_path . 'public/',
            $plugin_path . 'public/partials/',
        );

        foreach ($paths as $path) {
            $filepath = $path . $file;

            if (file_exists($filepath)) {
                ob_start();
                include $filepath;

                return ob_get_clean();
            }
        }

        return false;
	}
}

if ( ! function_exists( 'bw_load_booking_engine' ) ) {
	function bw_load_booking_engine($content) {
        $beforecontent = bw_booking_page_content();
        $fullcontent = $beforecontent . $content ;
        return $fullcontent;
	}
}

if ( ! function_exists( 'bw_is_booking_page' ) ) {
	/**
	 *
	 * @return bool
	 */
	function bw_is_booking_page() {
		global $post;

		$returnValue = false;

		if ( isset( $post ) && ( get_post_meta( $post->ID, 'bookwize_integrated_page_type', true ) === 'integrated' ) ) {
			$returnValue = true;
            add_filter('the_content', 'bw_load_booking_engine');
		}
        return $returnValue;
	}
}

if( ! function_exists( 'bw_booking_page_content' )){
    function bw_booking_page_content(){
        return bw_render('bookwize-public-display');
    }
}